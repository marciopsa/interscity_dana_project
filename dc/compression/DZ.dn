data GZHeader {
	byte ID1
	byte ID2
	byte CM
	const byte FLG_FTEXT = 0x1
	const byte FLG_FHCRC = 0x2
	const byte FLG_FEXTRA = 0x4
	const byte FLG_FNAME = 0x8
	const byte FLG_FCOMMENT = 0x10
	byte FLG
	int4 mtime
	byte XFL
	byte OS
}

data Int4 {
	int4 val
}

const char debugMSG[] = "[@DZIP]"

component provides compression.Compression requires io.Output out, data.IntUtil iu,
	io.File, compress.algorithm.StreamCompression:deflate compressor, data.checksum.CRC32 crc32 {
	
	byte[] append(byte copyBuf[], byte fileName[], byte trailing[], 
		byte comContent[], byte crc[], byte size[]) {
		out.println("copyBuf: $(copyBuf)")
		out.println("trailing: $(trailing)")
		//out.println("comContent: $(comContent)")
		out.println("crc: $(crc)")
		out.println("size: $(size)")
		return new byte[](copyBuf, fileName, trailing, comContent, crc, size)
	}

	byte[] writeInt4(int4 val) {
		Int4 i4 = new Int4()
		i4.val = val
		byte copyBuf[] = dana.getByteArrayOf(i4)
		//deal with endianness
		byte swap
		swap = copyBuf[3]
		copyBuf[3] = copyBuf[0]
		copyBuf[0] = swap
		swap = copyBuf[2]
		copyBuf[2] = copyBuf[1]
		copyBuf[1] = swap
		return copyBuf
	}

	byte[] Compression:compress(byte content[]) {
		GZHeader mainHeader = new GZHeader()
		mainHeader.ID1 = 31
		mainHeader.ID2 = 139
		mainHeader.CM = 8
		mainHeader.FLG |= GZHeader.FLG_FNAME
		mainHeader.OS = 255
		byte copyBuf[] = dana.getByteArrayOf(mainHeader)
		//compression content
		byte comContent[]
		int4 crc
		compressor.compressInit()
		crc = crc32.makeCRC(crc, content)
		comContent = compressor.compress(content, true)
		compressor.compressEnd()
		return append(copyBuf, "", 0, comContent, writeInt4(crc), writeInt4(content.arrayLength))
	}

	char[] Compression:algorithmName() {
		return "gzip"
	}

	char[] Compression:getExtension() {
		return ".gz"
	}
}
